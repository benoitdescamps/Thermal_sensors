import numpy as np

class HeatSource(object):
    """
    Decribes the properties of a source of heat gain or loss. This source could either be
    controllable such as a radiator or uncontrollable such as window.
    The device is currently assumed to be squared.

    Args:
        float T: Temperature of the source. Currently we assume that it is constant over
                the device. In development, the device is a stationary boundary condition
                of the heat equation.
        Int x0: lowest x-coordinate of the device
        Int x1: highest x-ccordinate of the device
        Int y0: lowest y-coordinate of the device
        Int y1: highest y-ccordinate of the device
        Str name: name of device
        Boolean controllable: Set True is the Temperature of the device is controllable
    """
    def __init__(self,T,x0,x1,y0,y1,name,controllable=False):
        self.name = name
        self.T = T
        #self.Told = T
        self.x0 = x0
        self.x1 =x1
        self.y0 = y0
        self.y1 =y1
        self.is_oontrollable = controllable
    def act_on_source(self,Tnew):
        """
        Sets the Temperature
        :param float Tnew: new Temperature
        """
        assert(self.is_oontrollable),"Only controllable devices can have their temperature changed after initiation"

        self.T = Tnew

    def apply_source(self,image):
        """
        Applies the temperature of the device. In development, this is used
        to impose the device's temperature as a boundary of the heat equation
        :param np.array image: thermal image
        """
        image[self.x0:self.x1,self.y0:self.y1] = self.T
        self.Told = self.T
        return image
    def get_heat_loss(self,img):
        """
        Computes the mean heatflow due to the device.
        In development, this is simply the average of the temperature array generated
        from the heat equation minus the past Temperature, i.e. the set device temperature. this is
        because [in development] the device is a stationary boundary condition.
        :param np.array img: thermal image
        """
        return np.mean(img[self.x0:self.x1,self.y0:self.y1]-self.T)
    def get_heat_img(self,img):
        """
        Generate the room image to the image [Temperature array] of the device
        :param np.array img: thermal image
        :return: np.array
        """
        return img[self.x0:self.x1,self.y0:self.y1]
class Room(object):
    """
    Room represented by a thermal image

    Args:
        np.array image: thermal image capture by the sensor
    """
    def __init__(self,image):
        self.image = image
        self.heat_sources = list()

    def add_heat_source(self,heatsrc):
        self.heat_sources.append(heatsrc)

    def _apply_heat_sources(self):
        """
        [Only for Development]

        applies the device as stationary boundary condition to the heat equation

        """
        heat_loss = 0.0
        for heatsrc in self.heat_sources:
            if heatsrc.is_oontrollable:
                heat_loss+= heatsrc.get_heat_loss(self.image)
            heatsrc.apply_source(self.image)
        return heat_loss

    def propagate(self,dt,dx,dy,n_steps):
        """
        [Only Development]
        Applies n_steps time step of the heat-equation
        Args:
            :param float dt: delta time
            :param float dx: delta x-dim
            :param float dy: delta y-dim
            :param Int n_steps: number of discretized time steps of the heat equation to apply
            :return: heatloss generated by the controllable device
        """
        heat_loss = 0.0
        for n in range(n_steps):
            self.image[1:-1:,1:-1:] = self.image[1:-1:, 1:-1:] + dt*(np.diff(self.image, n=2, axis=0)[:,1:-1:]/(dx*dx) \
                                               + np.diff(self.image, n=2, axis=1)[1:-1:,:]/(dy*dy))
            self.image[0, :] = self.image[1, :]
            self.image[:, 0] = self.image[:, 1]
            self.image[-1, :] = self.image[-2, :]
            self.image[:, -1] = self.image[:, -2]

            heat_loss += self._apply_heat_sources()*dx*dy*dt
        return heat_loss

    def get_room_temperature(self):
        """
        Estimates the global temperature of the room from the thermal image

        :return:
        """
        #TODO: eventually change this to @property
        return np.median(self.image)



